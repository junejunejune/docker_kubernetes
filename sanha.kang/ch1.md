# 쿠버네티스 (kubernetes, k8s)

# Bite

- 도커 아키텍처는 서버/클라이언트 구조이며 서버인 도커 데몬이 클라이언트인 도커 커멘드로부터 요청을 받아 동작한다
- k8s 클러스터는 마스터와 노드로 구성된다
- CNCF가 배포하는 쿠버네티스가 기본이며, 클라우드 업체가 자사 제품을 위해 독자적으로 기능을 추가&확장한다
- 파드 == 컨테이너 ..?
- kubectl == CLI
- 하나의 파드에 속하는 모든 컨테이너들은 같은 노드에서 동작한다
- 파드나 컨테이너는 실행 시에만 존재하는 일시적인 존재이다
- 파드의 기동과 삭제는 컨트롤러에 의해 동적으로 실행되기 때문에 언제까지 동일한 IP 주소를 가지고 있을지 알수 없다. ***그래서 파드에 요청을 보내고 싶은 경우 반드시 서비스를 사용해야한다***
- '파드내 모든 컨테이너가 실행중이다' 이말 이해되도록 하기

# 질문

- 컨테이너당 이미지는 고정인가?

# 마스터

- 클러스터 전체를 관리하는 컨트롤러로써 마스터가 존재

# 노드

- 컨테이너가 배포되는 머신 (가상머신이나 물리적인 서버머신)인 노드가 존재

# 오브젝트

- 가장 기본적인 구성단위가 되는 기본 오브젝트(Basic object)와,
- 이 기본 오브젝트(Basic object) 를 생성하고 관리하는 추가적인 기능을 가진 컨트롤러(Controller) 로 이루어진다
- 그리고 이러한 오브젝트의 스펙(설정)이외에 추가정보인 메타 정보들로 구성이 된다고 보면 된다.

## 오브젝트 스펙 (Object Spec)

오브젝트들은 모두 오브젝트의 특성 (설정정보)을 기술한 오브젝트 스펙 (Object Spec)으로 정의가 되고, 커맨드 라인을 통해서 오브젝트 생성시 인자로 전달하여 정의를 하거나 또는 yaml이나 json 파일로 스펙을 정의할 수 있다.

## 기본 오브젝트 (Basic Object)

- 쿠버네티스에 의해서 배포 및 관리되는 가장 기본적인 오브젝트는 컨테이너화되어 배포되는 애플리케이션의 워크로드를 기술하는 오브젝트로 Pod,Service,Volume,Namespace 4가지가 있다.

- 간단하게 설명 하자면
    - Pod는 컨테이너화된 애플리케이션
    - Volume은 디스크
    - Service는 로드밸런서
    - Namespace는 패키지명

정도로 생각하면 된다

### Pod

- Pod 는 쿠버네티스에서 가장 기본적인 배포 단위로, 컨테이너를 포함하는 단위이다
- Pod는 하나 이상의 컨테이너를 포함한다
- 쿠버네티스의 특징중의 하나는 컨테이너를 개별적으로 하나씩 배포하는 것이 아니라 Pod 라는 단위로 배포하는데, Pod는 하나 이상의 컨테이너를 포함한다
- 간단한 Pod를 정의한 오브젝트 스펙이다

- 오브젝트 스펙 예시

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: nginx
spec:
  containers:
  - name: nginx
    image: nginx:1.7.9
    ports:
    - containerPort: 8090
```

# 파드

# 서비스

# 컨트롤러

# 쿠버네티스 API

# 도커 데몬

# 도커 커멘드

- 짧은 유형, 이해하기 쉬운 유형 두가지가 있다

```bash
# 같은 의미
$ docker ps
$ docker container ls

```

# 15단계로 배우는 도커와 쿠버네티스

## 1-1장. 도커와 쿠버네티스의 개요 - 쿠버네티스란?

### 컨테이너화의 의의와 쿠버네티스 개요

- 지속적 통합과 지속적 배포를 통해 사용자에게 새로운 기능과 서비스를 빠르고 안정적으로 제공할 수 있도록 컨테이너 기술 이러한 요구 사항을 효과적으로 만족시키기 때문이다
- 개발자들간의 개발 환경의 차이를 없애 개발 생산성과 안정성 얻는다
- 

### 1.1 쿠버네티스의 개요

- 주요 기능
    - 컨테이너 개수, CPU 사용률, 메모리 사용량 설정 가능
    - 저장 공간, 네트워크 접근 제어, 로드밸런싱 기능 설정 가능
    - 요청이 많아지만 컨테이너 수를 늘려서 처리 능력을 높음
    - 요청이 적을 때는 컨테인 수를 줄여서 자원 점유율이나 요금을 줄임
    - 새로운 버전의 애플리케이션을 무정지로 배포 가능
    - 하드웨어 가동률을 높여 자원 낭비 줄임

- 운영에 발생하는 다양한 부담을 줄여줌
    - 다양한 환경에서 쿠버네티스 사용 가능
        - 퍼플릭 클라우드:고객들간 공ㅇ유하지만 저렴하고 빠른 운영 가능
        - 프라이빗 클라이드: 독점 사용
        - 멀티 클라우드: 여러 퍼플릭 쿨라우드
        - 하이브리드 쿨라우드: 온프레미스와 퍼플릭 쿨라우드 함께
        - 온프레미스: 자사 설비를 이용해 애플리케이션에 특화된 운영
    - 계속되는 변화를 전제로 설계된 높은 유연성과 확장성
        - 마이크로서비스 애플리케이션에 최적화된 실행 환경
        - 느슨한 결합에 의한 유연성, 교체 용이성
        - 서버(노드)의 정지, 추가, 제거 용이
        - 다양한 스펙의 서버가 혼재하는 클러스터 구성에 사용 가능
        - 저장소나 로드밸런서의 동적 프로비저닝
        - 퍼블릭 클라우드 API와 연동한 쿠버네티스 조작
    - 고가용성과 성능 관리
        - 서버 정지 시 애플리케이션 재배포 자동화
        - 애플리케이션 이상 종료시 자동 재기동
        - 필요한 인스턴스의 개수 유지
        - 높은 부하에서 자동 스케일

### 1.4 쿠버네티스가 해결하는 과제

쿠버네티스가 효과적으로 해결하는 문제들

과제1: 애플리케이션의 빈번한 출시

- 쿠버네티스의 롤아웃 롤백 기능 사용하여 빈번하게 출시하고 버그 수정을 긴급 투입할 수 있다

과제2: 무정지 서비스

- 쿠버네티스의 자기 회복 기능은 무정지 서비스 운영을 둡니다. 응답이 없는 컨테이너를 재기동할 수 있다

과제3: 초기 비용을 낮추고 비지니스 상황에 맞게 규모를 조정

과제4: 쿠버네티스와 외부 서비스 연동

과제5: 개발 환경과 운영 환경 분리

과제6: 온프레미스와 클라우드 위에 구축

과제7: 애플리케이션 중심의 오케스트레이션

과제8: 특정 기업에 종속되지 않는 표준 기술

과제9: 서버들의 가동률 높이기

### 1.5 쿠버네티스 아키텍처

단 두 종류의 서버로 구성

- 마스터
    - 클러스터 관리 담당
    - kubectl과 같은 API 클라이언트로부터 요청을 받아서 애플리케이션의 배포, 스케일업/다운, 컨테이너의 버전 업 등의 요구를 처리한다
    - 마스터는 클러스터의 단일 장애점이 되지 않도록 다중화할 수 있다
- 노드
    - 컨테이너화된 애플리케이션을 실제로 실행

- 클라우드 문서에는 마스터는 마스터 노드 노드를 워커 노드로 기재하기도 한다. (노드는 초기에 미니언이라 불리기도 했다)
- 유저 요청이 늘어나면  처리 능력을 늘려야 하는데 기본적으로는 컨테이너 수를 늘리면되고 이때 노드 수를 늘려야할 때도 있는데  1.11 버전 기준 최대 5,000대의 노드를 연결 가능하다
- 노드를 추가하고 제거하는 작업은 애플리케이션이 돌아가는 중에도 할 수 있다
- 클러스터의 외부에는 레지스트리가 있다. 이는 도커의 레지스트리와 동일하다. 각 노드에서 이미지를 다운로드할 수 있도록 네트워크 상 접근 가능한 곳에 있어야한다
- 마스터는 노드를 제어하고 노드에서 컨테이너가 돌아간다

## 1-2장. 도커와 쿠버네티스의 개요 - 컨테이너의 이해?

- 컨테이너화된 애플리케이션을 운영하는 쿠버네티스도 일부 모듈이 컨테이너로 되어있다

### 2.1 컨테이너를 사용하는 이유

- 이러한 특징 때문에 컨테이너가 가상 서버보다 우수한 애플리케이션 실행 환경이라고 여겨진다

1. 인프라 사용률 향상
    - 하나의 물리 서버나 가상 서버 위에서 여러 개의 컨테이너를 돌릴 수 있다
    - CPU와 메모리 사용률을 높여 하드웨어를 효율적으로 이용할 수 있다
2. 빠른 기동 시간
    - 컨테이너 기동시간은 가상 서버나 물리 서버의 기동 시간보다 훨씬 빠르다
    - OS, 애플리케이션, 미들웨어 등 다양한 이미지를 쉽게 얻을 수 있다
    - 설치&설정 작업이 줄어든ㄷ
    - 네트워크, 볼륨을 소프트웨어 정의 오브젝트로 작성할 수 있다
3. 불별 실행 환경 (Immutable Infrastructure)
    - 애플리케이션 실행에 필요한 소프트웨어를 모두 포함하여 컨테이너를 작성할 수 있다
    - 컨테이너를 조합하여 시스템을 구성함으로써 특정 서버 환경에 대한 종속성을 배제할 수 있다
    - 개발 환경과 운영 환경의 차이를 줄일 수 있다

### 2.2 가상 서버와 컨테이너의 차이점

가상서버

- 가상 서버는 가상화 소프트웨어를 사용하여 하드웨어를 공유한다
- 마치 한대의 전용 서버가 있는 것처럼 이용할 수 있다
- 한대의 머신에서 여러 가상 서버를 가동하여 하드웨어 추가 구입이 필요하지 않다
- 이러한 가상화 소프트웨어를 하이퍼바이저라 부른다 (VMware, Xen, KVM, VirtualBox, Hyper-V

컨테이너

- 컨테이너는 하나의 리눅스 프로세스가 마치 전용 서버에 동작하고 있는 것 같은 분리 상태를 만들어 낸다
- 이는 리눅스 커널의 네임스페이스와 컨트롤 그룹(cgroup)이라는 기술을 기반으로 한다

가상 서버와 컨테이너의 차이

![%E1%84%8F%E1%85%AE%E1%84%87%E1%85%A5%E1%84%82%E1%85%A6%E1%84%90%E1%85%B5%E1%84%89%E1%85%B3%20(kubernetes,%20k8s)%20858971d1cc0b4e62969c698dca7a30c7/Untitled.png](%E1%84%8F%E1%85%AE%E1%84%87%E1%85%A5%E1%84%82%E1%85%A6%E1%84%90%E1%85%B5%E1%84%89%E1%85%B3%20(kubernetes,%20k8s)%20858971d1cc0b4e62969c698dca7a30c7/Untitled.png)

[제목 없음](https://www.notion.so/1df0e6301f654d5988e9c5797cf5aabe)

중요

```swift
윈도우내 맥에서 컨테이너를 돌리려면 리눅스 커널을 위해 가상 서버가 필요하다.
docker Community Edition을 윈도우나 맥에 설치하면 하이퍼바이저 위에서 LinuxKit이 기동하여 
그위에서 컨테이너의 런타임인 containerd가 기동한다
 윈도우는 Hyper-V를 사용하고 맥은 Hypervisor.framework를 기반으로 하는 HyperKit를 사용한다
LinuxKit는 컨테이너를 실행하기 위한 경량의 리눅스 서브 시스템으로 여러기업이 만든 오픈 소스이다

위 그림처럼 컨테이너는 하이퍼바이저상의 가상 서버에서도 사용할 수 있어 퍼블릭 클라이두의 가상 서버나 온프레미스의
OpenStack 위에서 많이 활용된다.
 가까운 미래에는 LinuxKit으로 표준화된 리눅스 커널을 통해 애플리케이션이 컨테이너 위에서 실행되는 것이 당연해
지는 시대가 될 것이다
```

### 2.3 도커의 아키텍처

- 도커는 소프트웨어 개발자가 컨테이너를 Build, Shop, Run할 수 있도록 `도커 데몬 서버`, `클라이언트인 도커 커맨드`, `이미지 보관소인 레지스트리` 로 구성된다

![%E1%84%8F%E1%85%AE%E1%84%87%E1%85%A5%E1%84%82%E1%85%A6%E1%84%90%E1%85%B5%E1%84%89%E1%85%B3%20(kubernetes,%20k8s)%20858971d1cc0b4e62969c698dca7a30c7/Untitled%201.png](%E1%84%8F%E1%85%AE%E1%84%87%E1%85%A5%E1%84%82%E1%85%A6%E1%84%90%E1%85%B5%E1%84%89%E1%85%B3%20(kubernetes,%20k8s)%20858971d1cc0b4e62969c698dca7a30c7/Untitled%201.png)

1. 도커 데몬
    - 도커 데몬은 클라이너트인 도커 커멘드의 명령을 받아들여 이미지, 컨테이너, 볼륨, 네트워크와 같은 도커 오브젝트을 관리한다
    - 도커 데몬은 네트워크 너머에 있는 원격 클라이언트로부터 요청을 받는 것도 가능하다
2. 도커 클라이언트
    - 보통 컨테이너 호스트에서 클라이언트 실행
    - 설정에 따라 원격에서 클라이언트 실행하는 것도 가능
3. 도커 커멘트
    - 도커 커멘트듣 컨테이너를 조작하는 CLI로 도커 데몬의 클라이언트다. 도커 커멘드는 도커 API를 사용하여 도커 데몬에 요청을 보낸다

    `도커 클라이언트랑 도커 커멘트는 같은 말인 듯`

    - 자주 사용하는 도커 커멘드

    ```bash
    $ docker build # 베이스 이미지에 기능을 추가하여 새로운 이미지를 만들 때 사용
    $ docker pull # 레지스트리에서 이미지를 로컬에 다운로드할 때 사용한다
    $ docker run # 이미지로 컨테이너를 실행한다
    ```

4. 컨테이너 호스트
5. 이미지
    - 읽기 전용인 컨테이너 템플릿
    - 컨테이너를 기등하기 위한 실행 파일과 설정 파일의 묶음
    - 도커허브에는 DB, 웹서버, 애플리케이션 등 다양한 이미지 존재
    - 호스트으 로컬에 이미지가 존재하지 않은 경우  자동으로 원격 레지스트리에서 다운받아 실행한다
    - 로컬에 이미지만 다운로드 받고 싶다면 `docker pull` 을 다운로드&실행까지 하고 싶다면 `docker run` 명령어를 사용한다
    - 대부분의 이미지는 다른 이미지에 기반하여 만들어진다. 예를 들어 웹서버인 Nginx의 컨테이너는 리눅스 배포판인 데비안에 기반하여 만들어졌다. 이미지를 만들 때는 기반 이미지와 설치 스크립트 등을 `Dockerfile`에 기재하여 빌드한다
6. 컨테이너
    - 컨테이너는 하나의 프로세스라고 볼 수 있다
    - 리눅스의 네임스페이스나 컨트롤 그룹(Cgourps)을 통해 다른 프로세스들과 완전히 분리되어 실행되는 프로세스인 것이다.
    - 하지만 컨테이너는 정지 상태일 때도 관리되기 떄문에 `실행 가능한 이미지의 인스턴스` 라고 할수 있다
    - docker run 명령을 통해 이미지는 컨테이너로 변환되어 하나의 인스턴스가 된다
    - 실행 상태의 컨테이너는 IP 주소를 가지는 하나의 독립된 서버처럼 동작한다
    - 컨테이너의 IP주소와 포트번호로 온 요청은 컨테이너 내의 프로세스로 연결된다
    - docker run 명령시 파라미터를 전달하여 동작을 바꿔 다양한 상황에서 재사용할 수 있다
    - 컨테이너를 정지하고 싶을 때에는 docker stop , docker kill 명령을 사용한다.  차이점은 정상 종료를 기다릴지 아니면 바로 강제 종료할지 여부이다. 이때 컨테이너는 정지 상태가 되는 것이지 삭제가 되진 않는다. 정지 상태의 컨테이너는 docker rm 에 의해 지워지기 전까지는 기동했을 때의 실행 옵션과 로그를 간직한다. 정지된 컨테이너르 ㄹ다시 기동할 때는 docker start 명령을 사용한다. 이 때 주의할 점은 정지전의 IP가 유지 되지 않는다.
7. 도커 레지스트리
    - 컨테이너 이미지가 보관되는 곳이다
    - 기본으로 도커 허브에 있는 이미지를 찾는다
    - docker run hello-world 를 실행하면 공개 레지스트리인 도커 허브에 등록된 이미지 hello-world 다운받아서 컨테이너로서 실행한다
    - 레지스트리와 레포지터리
        - 래지스트리가 큰 개념이다
        - 레지스트리는 리포지터리를 여러개 가지는 보관 서비스이다
        - 리포지터리는 하나의 이미지에 대한 태그를 사용하여 다양한 출시 버전을 함께 보관하는 곳이다
    - 퍼플릭 레지스트리
        - 누구나 사용, 도커 허브의 경우 리포지터리 공개시 무료, 비공개시 유료
        - git에 있는 Dockerfile 이나 소스코드를 편집하여 push하면 자동으로 이미지를 빌드하고 리포지터리에 등록해 주는 자동화 서비스도 있다
        - 컨테이너의 취약성을 검사하여 보고서를 제공하는 기능을 갖춘 레지스트리도 있다.
        - 대표적인 공개 레지스트리
            - Docker Hub
            - Quay
    - 클라우드 레지스트리
        - 퍼블릭 클라우드가 제공하는 레지스트리 서비스다
        - 접근 가능 계정을 제한하여 비공개 운영 가능
        - 인터넷 공개도 가능
        - 대표적인 클라우드 레지스트리
            - Amazon Elastic Container Registry
            - Azure Container Registry
            - Google Container Registry
            - IBM Cloud Container Registy
    - 비공개 레지스트리
        - 회사 전용으로 레지스트리를 구축하여 운영하는 경우 해당
        - 공개 레지스트릴 전용 레지스트리를 구축하거나 오픈 소스로 이용할 수 있다
        - 대표적인 오픈 소스 레지스트리 소프트웨어
            - Harbor
            - GitLab
            - Registry

### 2.3 레지스트리와 쿠버네티스 관계

- 쿠버네티스트에서도 레지스트리에서 이미지를 다운로드받아 컨테이너를 실행한다
- 쿠버네티스ㅔ서 컨테이나가 동작할 때까지의 흐름은 다음과 같다
    1. docker build 로 이미지 빌드
    2. docker push 로 이미지를 레지스트리에 등록
    3. kubectl 커맨드로 매니페스트에 기재한 오브젝트들의 생성을 요청
    4. 매니페스트에 기재된 리포지터리로부터 컨테이너의 이미지 다운로드
    5. 컨테이너를 파드 위에서 기동

### 2.5 도커와 쿠버네티스의 연동

- 쿠버네티스는 도커를 컨테이너의 런타임 환경으로 사용한다
- 쿠버네티스를 설치할 때 제일 먼저 도커를 설치해야는 이유이다
- 도커 데몬 프로세스인 dockerd 와 연동하여 동작하는 containerd 프로세스는 원래 도커 기업이 개발했다. 이후 2017 3월 런타임 표준화를 위해 도커에서부터 CNCF로 기증되어 개발되었다. 이후 containerd 는 다양한 플랫폼 위에서 동작하는 업계 표준 코어 컨테이너 런타임으로 간결하고 높은 이식성을 목표로 개발 되었다
containerd 는 Docker CE 17.3에서 버전 0.2.3이 도입되었고 Docker CE 17.12에서는 1.1이 되었다. 이를 통해 이미지 보관 및 전송, 컨테이너 실행, 볼륨과 네트워크 연결과 같은 컨테이너의 라이프 사이클을 호스트에서 완전히 관리할 수 있게 되었다
- contaierd의 버전 1.1부터는 CRI(Container Runtime Interface)에 대응하여 네이티브 kubelet도 연동할 contaierd수 있게 되었다
- contaierd는 OCI(Open Container Interface)의 표준 사양에 준하는 컨테이너 런타임 runC를 사용한다
- CRI를 통해 컨테이너 실행 요청을 받으면 containerd는 containerd-shim을 만든다(shim은 틈을 메워서 높이니 수평 맞추는 것을 의미, 여기서는 containerd와 runC의 틈을 매워준다)
- runC는 컨테이너를 띄운 후 바로 종료하며, 이어서 container-shim이 프로세스로 남게된다

이와 같이 내부 표준화가 진행됨에 따라 향후 쿠버네티스의 컨테이너 실행 환경은 도커 설치를 필수로 하지 않게 되어, 보다 심플하고 경량으로 고속화될 수 있는 방향으로 개발이 진행되고 있다

 퍼플릭 클라우드의 쿠버네티스 관리 서비스와 상용 제품에서도 containerd와 kubelet이 직접 연계하는 방향으로 진행되고 있다. IBM Cloud Kuberetes Service에서도 버전 1.11이후에는 도커를 이용하지 않게 되었다

### 2.6 컨테이너를 위한 기술과 표준

 컨테이너를 구성하는 기반 기술들에 대해 간단히 살펴보자

리눅스 표준 규격과 리눅스 ABI(Application Binary Interface)

- Docker CE(버전 16.04.0-ce)에서 리눅스의 여러 배포판을 실행하면 ㅋ컨테이너의 커널은 4.9.93-linuxkit-aufs가 사용된다
- 이처럼 리눅스 배포판과 커널 버전이 달라도 동작하는 이유는 다음과 같다
    - 먼저 LBS(Linux Base Standard)는 소스 코드를 컴파일한 시점에서 호환성 있는 머신 코드를 생성하도록 ISO 규격으로 표준화되어 있다
    - 또한 리눅스 ABI(Application Binary Interface)로 인해 리눅스 커러널의 버전이 올라가도 유저 공간에서 동작하는 바이너리(머신 코드) 레벨의 호환성은 유지된다

리눅스 커널 기술

- 네임스페이스
    - 리눅스 커널에서 사용되는 기술로 컨테이너가 하나의 독립된 서버와 같이 동작할 수 있게 한다
    - 네임스페이스를 사용하면 특정 프로세스를 다른 프로세스로부터 분리시켜 같은 네임스페이스 내에서만 접급할 수 있도록 제한할 수 있다

[네임스페이스의 종류와 역할
](https://www.notion.so/fe2806aee64e4ce58466255bbefcdee8)

- cgroup(컨트롤그룹)
    - 도커는 리눅스 커널의 cgroup을 사용한다
    - cgroup은 프로세스별로 CPU 시간이나 메모리 사용량과 같은 자원을 감시하고 제한한다

유니온 파일 시스템(UnionFS)

- UnionFS은 다른 파일 시스템에서 파일이나 디렉토리를 투과적으로 겹쳐서, 하나의 일관적인 파일 시스템으로 사용할 수 있게 한다
- 도커는 UnionFS의 여러 구현체(aufs, btrfs, overlay2) 중 하나를 선택할 수 있다
- 예전에는 aufs가 사용 되었으나, Docker CE 버전 17.12에서는 보다 빠르게 동작하고 구조가 간단한 overlay2가 사용된다

OCI(Open Container Initiative)

- 컨테이너의 표준 사양할 책정하기 위해 2015년 6월에 만들어지는 단체로 설립 초기에는 Docker가 사실상 컨테이너의 표준이였는데 CoreOS가 또다른 표준화를 진행하고 있어 업계 표준이 필요하였고 Docker, 구글, IBM, 레드햇, AWS, VMWare, HP, MS, 리눅스 파운데이션 등이 참여하여 2017년 OCI v1.0을 통해 컨테이너 런타임 표준 사양인 Runtime Specification v1.0과 이미지 포맷 표준 사양인 Format Specification v1.0을 발표하였다
- 이에 맞춰 Docker가 구현한 것이 runC이고 CoreOS 컨테이너 런타임 rkt도 내부적으로 표준에 맞추는 작업이 진행 중이다

### 마무리

- 도커 아키텍처는 서버/클라이언트 구조이며 서버인 도커 데몬이 클라이언트인 도커 커멘드로부터 요청을 받아 동작한다
- 가상 서버와 비교했을 때 컨테이너는 (1) 경량, (2) 빠른 기동, (3) 이식성이 장점이다
- 컨테이너 사용 의의는 (1) 인프라 사용 효율 향상, (2) 빠른 기동 시간, (3) 불변 실행 환경이 있다
- 컨테이너의 이미지를 보존하는 레지스트리는 개발한 컨테이너 이미지를 쿠버네티스에서 실행하기 위한 중간 창고와 같은 역할이다
- 쿠버네티스 스택은 예전부터 주로 도커를 런타임 환경으로 사용했는데, CRI(Container, Runtime Interface)로 컨테이너 실행 환경과 연동하는 식으로 발전하고 있다
- 컨테이너 내의 실행파일은 리눅스의 표준 규격 LBS(Linux Base Standart)와 리눅스 ABI(Application Binary Interface)에 의해 실행이 보증된다. 그리고 컨테이너 OCI(Open Container Initiative)가 정하는 업계 표준을 지킴으로써 이식성이 확보된다

## 1-3장. 도커와 쿠버네티스의 개요 - 쿠버네티스의 기본

 본격적인 실습에 앞서 쿠버네티스의 기본적인 구조를 알아보자

### 3.1 쿠버네티스 아키텍처

쿠버네티스 업스트림의 기본 구성 (그림1)

- 퍼플릭 클라우드의 쿠버네티스 관리 서비스에는 추가적인 컴포넌트들이 있다
- 그리나 업스트림의 핵심 기능이 가장 중심이다

실행 예

- 멀티 노드 k8s에서 마스터를 포함한 모든 노드에서 동작하는 파드의 목록을 출력한 결과

```bash
$ kubectl get pods -all-namespaces --sort-by=.sepc.nodeName -o=custom-column=NODE:.spec.nodeName,NAME:.metadata.name,IMAGE:.spec.containers[0].image
```

[제목 없음](https://www.notion.so/4ab3c071d29b4c919b677e63fa614e2a)

k8s 클러스터를 구성하는 코어 프로세스(컨테이너)

- kubectl
    - k8s 클러스터를 조작하기 위한 도구로 가장 빈번하게 이용되는 CLI이다
- kube-apiserver
    - kubectl 등의 API 클라이언트로부터 오는 REST 요청을 검증하고 API 오브젝트를 구성하고 상태를 보고한다
- kube-scheduler
    - 쿠버네티스의 기본 스케줄러
    - 새로 생성된 모든 파드에 대해 실행할 최적의 노드를 선택해준다
    - 스케줄러는 파드가 실행 가능한 노드를 찾은 다음 점수를 계산하여 가장 점수가 높은 노드를 선택한다
- kube-controller-manager
    - 컨트롤러를 구동하는 마스터상의 컴포넌트

- cloud-controller-manager
    - API를 통해서 클라우드 서비스와 연께하는 컨트롤러로 클라우드 업체에서 개발
- etcd
    - k8s 클러스터의 모든 관리 데이터는 etcd에 저장된다
    - 이 etcd는 CoreOS가 개발한 분산 키/값 저장소로 신뢰성이 요구되는 핵심 데이터의 저장 및 접근을 위해 설계 되었다
- kubelet
    - kubelet은 각 노드에서 다음과 같은 역할을 수행한다
        - 파드와 컨테이너의 실행
        - 파드와 노드의 상태를 API 서버에 보고
        - 컨테이너의 동작을 확인하는 프로브 실행
        - 내장된 cAdvisor를 통해 메트릭 수집 및 공개
- kube-proxy
    - kube-proxy는 각 노드에서 동작하며 로드밸런싱 기능을 제공한다
    - 서비스와 파드의 변경을 감지하여 최신 상태로 유지
    - iptables 규칙을 관리
    - 서비스명과 ClusterIP를 내부 DNS에 등록
- coredns
    - 파드가 서비스 이름으로부터 IP 주소를 얻기 위해 사용된다. 버전 1.11부터 kube-dns대신 coredns가 사용되었다. 이전 kube-dns가 부족했던 신뢰성, 보안성, 유연성이 coredns에서 개선되었다. CoreDNS 프로젝트는 CNCF가 관리한다

k8s를 구성하는 기본 플러그인

- kube-flannel
    - kube-flannel은 모든 노드에서 실행되어 여러 노드 사이에서 IPv4 네트워크를 제공
    - 이에 따라 컨테이너(파드)는 k8s 클러스터 내부에서 사용되는 IP 주소를 바탕으로 다르 노드에 있는 파드와 통신할 수 있다
    - 네트워크 접근제어가 필요한 경우에는 calico를 사용해야 한다
- calico-kube-controllers
    - calico를 위한 컬트롤러, 데이터 스토어로서 etcd를 이용하기 위해 사용된다
- calico-node
    - 모든노드에서 실행되어 노드 간 파드의 통신, 라우팅, 네트워크 접근 관리 기능을 제공한다
- kubernetes-dashboard
    - web 대시보드
- heapster
    - kebelet에 내장된 cAdisor로부터 메트릭 정보를 수집. 버전 1.11부터 지원 중단
- metrics-server
    - heapster를 대신하여 버전 1.8부터 도입되어있다. API의 aggregation layer를 통해서 k8s 클러스터를 전체로부터 메트릭을 수집한다

### 3.2 쿠버네티스 계층 구조

- 마스터 노드 역할
    - 쿠버네티스의 API 서버로서 클라이언트로부터의 명령을 받아들이고 실행
    - 컨테이너를 파드 단위로 스케줄링 및 삭제
    - 마스터는 각 노드의 CPU와 메모리 예약 상황, 실제 사용량을 감시한다
    - 새로운 파드를 배치해야할 때는 해당 파드의 매니페스트에 기재된 CPU와 메모리 요청값 및 상한값을 기준으로 조건에 부합하는 노드를 찾아서 파드를 스케줄한다. 즉, 파드의 실행을 할당한다
    - 파드의 컨트롤러 가능과 외부 리소스 관리

- 쿠버네티스의 스케줄링
    - 파드를 실행할 노드를 정하는 것을 의미

그림2 k8s 클러스터의 구성 개념도

   

### 3.3 쿠버네티스 API 오브젝트

쿠버네티스 API

- 쿠버네티스의 조작은 모두 API를 통해서 이뤄진다
- CLI인 kubectl은 마스터 노드상의 kube-apiserver에게 쿠버네티스 API 규약에 맞게 기술된 목표 상태 선언서인 매니패스트를 YAML 형식 혹은 JSON 형식으로 전송하여 오브젝트를 만들고, 바꾸고, 제거하는 일을 한다
- 파이썬, GO 등 다양한 프로그래밍 언어로 API 제공

오브젝트

- 쿠버네티스에서 오브젝트란 k8s 클러스터 내부의 엔티티이다
- 파드, 컨트롤러, 서비스 등 인스턴스를 의미
- 오브젝트를 쿠버네티스 API에 의해 설정되고 생성된다
- 오브젝트는 지정된 상태가 유지되도록 쿠버네티스에 의해 제어 된다
- 오브젝트는 메타데이터에 기술된 이름에 의해 식별된다 (오브젝트 생성시 이름은 필수)
- 같은 종류의 오브젝트의 이름은 하나의 네임스페이스에서 유일해야한다
- 네임스페이스
    - k8s 클러스터를 논리적으로 분할하여 사용하기 위해 존재하는 기능이다. 예를 들어, 쿠버네티스의 시스템 관련 기능을  수행하는 오브젝트들은 일반적인 애플리케이션들과 구별하여 네임스퍼에스에 kube-systemdp 만들어진다. 그리고 kubectl의 유효 범위는 지정한 네임스페이스로 제한된다

워크로드

- 워크로드란 오브젝트의 카테고리를 나타내는 용어로 컨테이너와, 파드, 컨트롤러의 그룹을 의미한다. 이들은 컨테이너의 실행을 관리하기 위해 사용된다
- 다만 이 책에서는 워크로드를 애플리케이션이나 프로그램의 부하를 의미하는 경우도 있다

컨테이너

- 쿠버네티스에서 컨테이너만 독자 실행하는 것은 불가능하고 반드시 파드 내에서 실행해야한다
- 컨테이너 기동 시 설정할 수 있는 항목은 이미지 이름, 실행 명령어, 실행 인자, 환경 변수, 불륨, CPU 사용시간과 메모리 크기의 요청값 및 상한 값 등이 있다

파드

- 파드는 컨테이너를 실행하기 위한 오브젝트이다
- 파드는 한 개 혹은 여러 개의 컨테이너를 담을 수 있으며, 이 구조는 완두콩이 콩을 담고 있는 모양과 비슷하다
- 그래서 꼬투리를 의미하는 영어 단어인 Pod가 이름이 되었다
- 매우 중요한 개념이다. 뒤에서 자세히 다룬다

컨트롤러

- 컨트롤러는 파드의 실행을 제어하는 오브젝트
- 여러 종류의 컨트롤러가 있고 각 컨트롤러의 기능을 이해하고 목적에 맞게 구별하여 사용해아함
- 예를 들어, 클라이언트 - 서버 모델에 적합한 디플로이먼트 컨트롤러는 서버가 돌아가는 파드의 개수가 지정한 숫자보다 적으면, 자동으로 지정한 개수가 되도록 파드를 기동시킨다. 그리고 배치 처리를 위한 잡 컨트롤러는 배치 처리가 정상 종료 될 때까지 재실행을 반복한다

설정 (Configuration)

- 

서비스 

- 쿠버네티스에서 서비스는 파드와 클라이언트를 연결하는 역할을 수행한다
- 즉, 서버 역할을 수행하는 파드가 클라이언트의요청을 받을 수 있도록 대표 IP주소를 취득하여 DNS에 등록한다
- 그리고 대표 IP주소로 요청 트래픽을 지정된 파드들에 부하분산하며 전송하는 역할도 수행한다
- 매우 중요한 개념이다. 뒤에서 자세히 다룬다

스토리지

- 파드나 컨테이너는 실행 시에만 존재하는 일시적인 존재이다. 때문에 중요 데이터는 컨테이너의 파일시스템에 저장해서는 안된다
- 데이터를 잃지 않기 위해 퍼시스턴트 볼륨을 사용하여야한다
- 하지만 복수의 노드에서 접속 가능한 퍼시스턴트 볼륨은 쿠버네티스의 범위에 포함되지 않는다. 때문에 외부 스토리지 시스템을 연동해야한다
- 다양한 외부 스토리지 시스템의 프로토콜과 API의 차이점을 은폐하기 위해 쿠버네티스는 스토리지를 계층적으로 추상화한 오브젝트를 제공한다

### 3.4 파드의 기본

- 파드는 한개 또는 여러 개의 컨테이너를 포함한다
- 파드는 쿠버네티스에서 컨테이너를 실행하는 최소 단위이다
- 하나의 파드에 속하는 모든 컨테이너들은 같은 노드에서 동작한다
- 파드는 IP 주소를 가진다
- 복수의 컨테이너를 내포한다
- 하나의 가상 서버처럼 동작한다
- 쓰고 버리고 새롭게 시작할 수 있도록 설계 되었다
- 파드를 단독으로 사용하진 않고 서비스, 컨트롤러, 퍼시스턴트 볼륨, 컨피그맵, 시크릿 등을 보젝트와 함께 사용된다

파드의 특징들

컨테이너 재사용 촉진을 위한 플랫폼

 파드는 하나의 목적을 위해 만들어진 컨테이너를 부품처럼 조합할수 있도록 설계되어있다

1. 파드 내부의 컨테이너들은 파드의 IP 주소와 포트를 공유한다
2. 파드 내부 컨테이너들은 localhost로 서로 통신할 수 있다
3. 파드 내부 컨테이너들은 System V 프로세스 통신이나 POSIX 공유 메모리를 사용하여 서로 통신할 수 있다
4. 파드의 내부 컨테이너들은 파드의 볼륨을 마운트하여 파일 시스템을 공유할 수 있다

위 4가지 기능은 같은 파드 내의 컨테이너 사이에서만 가능하다. 다른 파드에 있는 컨테이너와는 불가능 

파드는 일시적인 존재 

- 파드는 일시적인 조재로 실계되어 파드 내의 컨테이너는 이미지로부터 매번 생산된다
- 즉, 같은 오브젝트 이름으로 몇번이고 파드를 기동해도 이전에는 컨테이너에서 수행한 변경 이력은 남지 않고 이미지의 초기 상태에서 시작된다
- 파드의 IP 주소도 고장되어있지 않다. 파드 기동시 부여되며 종료시 회수된다
- 파드의 기동과 삭제는 컨트롤러에 의해 동적으로 실행되기 때문에 언제까지 동일한 IP 주소를 가지고 있을지 알수 없다
- ***그래서 파드에 요청을 보내고 싶은 경우 반드시 서비스를 사용해야한다***

파드는 컨테이너의 실행 상태를 관리

- 파드가 정지한 경우 담당 컨트롤러가 재기동 등의 정해진 처리를 수행하는 한편,
- 파드 내부의 컨테이너가 정지한 경우에는 파드가 해당 컨테이너를 재시작한다
- 설정에 따라 정지한 컨테이너를 그대로 유지한 채 로그를 참조할 수 있도록 하는 것도 가능
- 파드는  Liveness Probe(활성 프로브)와 Readiness Probe(준비 상태 프로프)를 설정하여 내부 애플리케이션의 상태를 감사할 수 있다. 예를들어 활성 프로브를 설정하면 애플리케이션이 멈춰 있는 상태를 감지하여 컨테이너를 강제 종료 시칼수 있다. 한편, 준비 상태 프로프를 설정하면, 파드 요청을 받을 준비가 될 때까지 서비스 오브젝트가 요청을 전송하지 않는다

파드는 초기화 전용 컨테이너를 실행

- 파드에 초기화 담당하는 컨테이너 설정 가능. 파드가 기동된 후 초기화 담당 컨테이너가 먼저 실행되어 초기화 후 핵심 기능을 수행하는 컨테이너들이 실행된다

### 3.5 파드의 라이프 사이클

- 쿠버네티스의 트러블 슈팅 중 가장 많이 발생하는 것이 파드의 기동 실패 원인 분석이다
- 개발 환경에서 컨테이너 이미지를 빌드하고 쿠버네티스 환경에 배포했을 때 제일 먼저 경험하는 것이 컨테이터가 기동하지 않거나 재시작을 반복하는 현상이다
- 이때 파드의 상태가 가지는 의미를 이해하고 적잘한 대처를 할 수 있어야 문제를 해결할 수 있다
- 문제를 파악하기 위해서는 kubectl get pods 를 실행하여 STATUS 열의 정보가 중요하다
- 이 필드의 정보는 Kubernetes API를 통해 획득하는데, 이 API를 통해서 얻을 수 있는 다양한 정보 중에서 도움이 될 만한 정보가 선별되어 STATUS 열에 표시된다

[kubectl get pod 결과 중 STATUS와 의미](https://www.notion.so/407d0d5a5d91426db5fc261d1df747ed)

### 3.6 파드의 종료 처리

 쿠버네티스는 종료 요청 시그널을 받은 컨테이너의 애플리케이션이 일정 시간 내에 종료 처리를 완료하고 정상 종료 하도록 요구한다

 예를 들어, 쿠버네티스에는 롤아웃이라 불리는 기능이 있다. 운영 중인 애플리케이션을 가동 중에 업데이트하는 기능이다. 이 기능을 담당하는 컨트롤러는 가동 중인 애플리케이션에 종료 요청을 시그널을 보내고 유예 시간까지 파드의 종료를 기다린다. 만약, 유예  시간 내에 종료되지 않으면 강제로 종료된다

 애플리케이션이 동작 중 강제 종료되면 데이터 분실 등의 장애로 이어질 수 있다. 따라서,  애플리케이션은 유예 시간 내에 메모리상의 데이터를 퍼시스턴트 불륨에 보존하거나 데이터베이스와의 세션을 종료하는 등의 종료 처리를 수행해야 한다. 만약에 이러한 요청에 대응하는 구현이 되어 있지 않다면  애플리케이션은 문제를 일으킬 소지가 있는 것이다

 파드가 삭제 요청을 받으면 컨테이너의 메인 프로세스에게 종료 요청 시그널(SIGTERM)을 보낸다. 만약 컨테이너에 종료 요청 시그널에 대한 처리가 구현되지 않은 경우에는 유예 시간 동안 기다린 뒤 강제로 종료된다. 이러한 흐름은 다음과 같이 정리할 수 있다

종료 처리의 흐름

1. 사용자가 kubectl delete pod를 실행하면 파드의 종료 처리가 시작된다. 기본 유예  시간은 30초이다
2. kubectl get pod의 status는 Terminating이라고 표시된다
3. 다음 3가지 작업이 동시에 진행된다
    - 파드의 PreStop hook이 정의되어 있으면 파드 내에서 호출된다. 유예 시간을 넘어서면 PreStop hook이 실행되고 있어도, 파드 내의 메인 프로세스에 SIGTERM이 보내지며, 2초 후에 SIGKILL로 강제 종료 된다
    - PreStop hook이 정의되어 있지 않다면, 곧바로 파드 내의 메인 프로세스에 SIGTERM 신호가 송신되며 종료 처리가 개시된다
    - 파드가 서비스의 엔드포인트 목록에서 제거되며, 로드밸런서(kube-proxy 등)의 목록에서도 제거된다
4. 유예 시간을 넘어서서 파드 내의 프로세스가 살아 있다면, 파드의 메인 프로세스에 SIGKILL을 보내서 강제로 종료한다
5. 제거 대상인 파드가 표시되지 않게 된다

- PreStop hook은 컨테이너가 종료되기 직전에 호출된다. 이것은 컨테이너 내의 프로세스가 종료 요청 시그널을 받을 수 없는 제약이 있는 경우에 종료 요청을 받는 수단이 된다
- `kubectl deelte —grace-period=xx초` 으로 유예 시간을 지정할 수도 있다

### 3.7 클러스터 네트워크

 클러스터 네트워크는 k8s 클러스터 내부에서 사용되는 네트워크이다. 파드는 이 네트워크상의 IP주소를 부여 받아 다른 노드에 있는 파드와 통신한다

 서비스의 IP주소나 포트번호를 k8s 클러스터 외부 네트워크에서 접근할 수있게 하려면, 서비스 타입을 NodePort 혹은 LoadBalancer로 설정하거나 인그레스를 함께 사용하면 된다

 한편, CNCF 문서를 보면 '클러스터 네트워크'라는 용어와 '파드 네트워크'라는 용어가 혼용되어 사용된다. 이책에서는 원칙적으로 클러스터 네트워크란 용어를 사용하지만, 노드가 접속하는 네트워크랑 혼동이 우려되는 경우에는 명확하게 구별될 수 있도록 파드 네트워크라고 쓰겠다

파드 네트워크

 파드 네트워크는 각 개발사의 특징을 살릴 수 있게 구현되었다. 여기서는 대표적인 오픈 소스 네트워크 애드온을 소개한다

Flannel

 간단한 L3 네트워크를 노드 간에 구축한다. 각 노드 위에 서브넷을 구성해서 한 노드 위의 파드가 다른 노드 위의 파드랑 통신할 수 있도록한다. Flannel의 하드는 데몬셋 컨트롤러에 의해 배포된다. 그래서 k8s 클러스터에 새로운 노드가 추가되면 자동적으로 파드 네트워크가 확장된다. Flannel은 네트워킹 기능만 을 갖추가 있으며, 접근 제어 기능은 제공하지 않는다

Calico

 노드 간 파드 통신에 더해 네트워크 접근 제어 기능을 제공한다. 예를 들어 2개의 네임스페이스 간에 통신을 금지하는 접근 제어 기능을 설정할 수 있다.

### 3.8 서비스의 기본

- 쿠버네티스의 서비스는 클라이언트의 요청을 파드에 전달한다
- 이러한 서비스가 필요한 이유는 `파드의 IP주소`가 기동할 때마다 바뀌기 때문이다
- 그래서 파드에 접속해야하는 클라이언트는 `서비스가 가지는 대표 IP`를 사용해서 접속한다

 지금부터 서버의 파드나 애플리케이션의 파드를 파드라하고, 클라이언트 파드나 클러스터 외부의 클라이언트를 클라이언트라고 하겠다

1. 서비스는 로드밸런서의 역할을 가지며, 클라이언트의 요청을 받기 위한 `대표 IP 주소`를 획득한다
2. 서비스의 이름은 내부 DNS에 등록되기 때문에 클라이언트는 서비스의 이름만으로 서비스의 IP주소를 얻을 수 있다
3. 서비스는 셀렉터에  지정된 라벨과 일치하는 파드 중 하나에게 요청을 전달한다
4. 서비스가 만들어지고 나서 기동된 파드의 컨테이너에는 서비스에 대한 정보가 담긴 환경 변수가 자동으로 설정된다
5. 서비스에는 네 종류의 서비스 타입이 있어, 
    - 클라이언트의 범위를 k8s 클러스터 내부로 한정할지,
    - 외부까지 확장할지,
    - 또한 k8s 클러스터 외부의 IP 주소에 전송할지를 설정한다

 3번의 내용은  쿠버네티스의 특징 중 하나이므로 추가 설명하면, 파드는 기동될 때 라벨이나 IP 주소를 포함한 자신의 오브젝트 정보를 `마스터 노드의 etcd`에 등록한다. 그래서 서비스의 전송처를 결정할 때 셀렉터의 라벨에 일치하는 파드를 etcd에 조회하여 전송할 파드의 IP 주소를 취득한다. ***이처럼 라벨에 의해 대상 오브젝트를 결정하는 것이  쿠버네티스의 기본 동작이다***

대표 IP 주소

 서비스는 파드의 그룹을 대표하여 클라이언트의 요청을 받기 위해 `대표 IP 주소(ClusterIP)`를 가진다. 헤드리스로 지정한 경우에는 대표 IP 주소를 획득하지 않고, 파드의 IP 주소를 직접 내부 DNS에 설정한다

부하분산

  서비스의 대표 IP 주소에 도착한 요청은 셀렉터의 라벨과 일치하는 파드에 전송된다. 이를 위한 모듈인 kube-proxy는 초창기에는 커널의 유저 공간에서 동작하는 프록시 서버였지만, 지금은 iptables나 ipvs를 관리하는 프로그램으로 바뀌었다

이름해결

 서비스 IP 주소와 서비스명을 k8s 클러스터의 내부 DNS에 등록한다. 그래서 k8s 클러스터 내의 파드에서는 서비스 이름으로 접근하는 것이 가능하다

환경변수

 서비스가 만들어지고 나서 생성되는 파드의 컨테이너에는 환경 변수가 설정되어 있다. 컨테이너 안의 애플리케이션 코드에서는 환경 변수를 이용해서 서비스의 대표 IP를 얻을 수 있다

서비스타입

 서비스를 설정할 때는 해당 서비스를 이용하는 클라이언트를 고려하여 서비스 타입을 지정한다. 예를 들면,  k8s 클러스터 내부 파드를 대상으로 하는 경우와 k8s를 클러스터 외부에서 접근하는 경우 고려하여 지정한다

어피니티

 기본적으로 부하분산에 사용되는 알고리즘은 랜덤이다. 클라이언트에 따라 전송되는 파드를 고정하고 싶은 경우에는 sessionAffinity 항목에 ClientIP를 설정한다. 그리고 HTTP 헤드 안의 쿠키(Cookie) 값에 따라 전송되는 파드를 고정하고 싶은 경우에는 뒤에서 설명할 인그레스를 이용해야한다

셀렉터와 라벨

 서비스에 도착한 요청 트래픽이 파드에 전송될 때는 셀렉터와 라벨을 참조한다. 라벨은 파드 등의 오브젝트에 부여하는 키값 쌍이다. 서비스에 도착한 요청은 셀릭터에 설정된 조건에 일치하는 라벨을 가지는 파드에 전송한다. 셀렉터의 라벨 조건이나 파드에 부여되는 라벨은 운영 중에도 바꿀 수 있어 유연하게 운영할 수 있다

### 3.9 컨트롤러 기본

 컨트롤러는 파드를 제어한다. 파드에게 부여할 워크로드의 타입, 즉 처리에 따라서 적잘한 컨트롤러를 선택해야 한다.

컨트롤러  ←제어→ 파드

컨트롤러 종류

- 디플로이먼트
- 레플리카셋
- 레플리케이션 컨트롤러
- 스테이트풀셋
- 잡
- 크론잡
- 데몬셋
- 가비지 컬렉션 등

컨트롤 내용

- 기동/정지/삭제
- 파드의 개수
- 자기 회복
- 퍼시스턴트 스토리지
- 디플로이 스케줄

워크로드 타입

- 프론트엔드 처리
- 벡엔드 서비스
- 처리 시간이 긴 배치 처리
- 정기 실행 작업
- 클러스터의 시스템 기능

### 워크로드 타입

프론트엔드 처리

- 스마트폰, IoT기기, 컴퓨터 등의 클라이언트로부터 요청을 직접 받아들이는 워크로드를 총칭한다. 이 타입의 워크로드는 대량의 클라이언트 요청에 대해 짧은 시간에 응ㄷ바을 반환하는 것이 중요하다.
- 예를들어, 일반 소비자를 대상으로 제공되는 애플리케이션은 서버 응답이 늦어서 유저를 답답하게 만들어서는 안된다. 광고를 전송하는 광고 네트워크에서는 방대한 유저의 관심사에 맞게 실시간으로 반응해야 한다. 그리고 IoT 기기로부터 요청은 기기로부터 끊임없이 만들어지는 데이터를 받아들이고 처리해야한다
- 이러한 워크로드 특성에 대응하기 위해서는 요청에 대응하는 처리를 복수의 파드에서 분담하도록 설계해야한다. 또한 24시간 무정지로 서비스를  제공하면서도 빠르게 신기능을 배포할 수 있어야한다

벡엔드 처리

 벡엔드 처리에서는 보통 MySQL이나 Redis와 같은 미들웨어를 사용하거나 클라우드 사업자가 제공하는 ㄷ이터베이스 관리 서비스를 활용한다. 다음과 같은 워크로드들이 있다

1. 데이터 스토어: 데이터의 보존과 조회 기능(SQL, NoSQL 데이터베이스 등)
2. 캐시: 복수 파드에서 데이터 공유(세션 정보 공유)
3. 메시징: 비동기 시스템 간 연계 기능(메시지 브로커)
4. 마이크로 서비스: 전문적 업무 기능 구현(결제, 배송, 결제 승인 등)
5. 배치 처리: 긴 처리 시간을 요구하는 업무 기능(기계학습이나 데이터 분석)

배치 처리(정기 실행 처리 포함)

시스템 운영 처리

### 컨트롤로의 타입

 컨트롤러는 앞에서 살펴본 다양한 워크로드를 처리하기 위해 파드를 제어하고 실행하는 역할을 담당한다. 대표적인 컨트롤러 7개의 역할과 특징을  살펴보자

디플로이먼트 (Deployment)

 대등한 관계에 있는 여러 개의 파드로 수평한 클러스터를 구성할 때 사용한다. 정해진 개수만큼 파드가 기동하도록 관리혐, 가동 중인 파드를 차례대로 교체하거나 규모를 조절할 수 있는 기능을 갖추고 있다

스테이트풀셋 (StatefulSet)

 파드와 퍼시스턴트 볼륨을 조합하여 데이터의 보관에 초점을 둔 컨트롤러다. 파드와 퍼시스턴트 볼륨에 번호를 매겨 관리함으로써 본질적으로 일시적인 존재인 파드가 상태를 가지는 워크로드를 처리할 수 있도록 해준다

잡 (Job)

 배치 처리를 하는 컨테이너가 정상 종료할 때까지 재실행을 반복하는 컨트롤러다. 파드 실행 횟수, 동시 실행수, 실행 횟수의 상한을 설정할 수 있으며, 지워 질 때까지 로그를 보존한다. 데이터 처리나 과학 분야의 계산 작업 등에 사용된다

크론잡 (CronJob)

 지정한 시각에 정기적으로 앞서 소개한 잡을 생성한다. UNIX에서 사용되는 cron과 같은 형식으로 잡을 생성 시각을 설정할 수 있다. 잡을 실행 완료한 파드를 몇 개까지 보관할 수 있는지 설정할 수 있어, 정기적으로 실행되어야 하는 배치 처리에 적합하다

데몬셋 (DaemonSet)

 k8s 클러스터의 모든 노드에서 같으 ㄴ파드를 실행하기 위해 존재한다. 예를 들어, 클러스터 네트워크를 구성하는 파드는 데몬셋에 의해 모든 노드에서 실행되며, 새로운 노드가 추가되면 해당 노드에서 자동으로 실행된다. 시스템 운영의 자동화에 적합하다

리플레카셋 (ReplicaSet)

 쿠버네티스의 예전 튜토리얼 등에서 언급되는데 차세대 컨트롤러인 디플로이먼트로 대체 되었다

### 워크로드와 컨트롤러의 대응

 워크로드와 컨트롤러 타입이 다르게 사용될 가능성이 충분하지만 아래와 같이 나타낼 수도 있다

[제목 없음](https://www.notion.so/cd480a4425e44ef6900633a92b32fcdf)

CPU 코어 수를 늘리거나 메모리 증설 등 노드의 스케일 업과 같은 긴능은 컨트롤러가 제공하지 않는다. 이러한 노드 스케일 업은 클라우드에서의 경우, 보다 많은 CPU 코어 수나 메모리 용량을 탑재한 노드를 준비해서 k8s 클러스터에 추가한 후, 파드의 노드 셀렉터를 설정해서 마이그레이션해야한다

마무리

- k8s 클러스터는 마스터와 노드로 구성된다
- CNCF가 배포하는 쿠버네티스가 기본이며 클라우드 업체나 솔루션 업체들이 자사 제품을 위해 독자적으로 기능을 추가하거나 확장하기도 한다
- 마스터는 목표 상태가 기술된 매니페스트를 받아들여서 그 상태가 유지되도록 오브젝트를 제어한다
- k8s 클러스터의 모든 조작은 쿠버네티스 API에 의해 실행되며, 오브젝트 작성, 수정, 삭제, 상태조회 등을 실행한다
- 주요 오브젝트로는 파드,, 서비스, 컨트롤러  세 가지가 있다
- 파드는 커네티어의 기동 단위이며 보통 서비스와 컨트롤러와 함께 사용된다
- 컨테이너 내 프로그램의 시그널 처리는 데이터 손실을 막고 안전하게 종료하도록 구현되어야한다
- 서비스는 클라이언트로부터의 요청을 지정한 파드의 그룹에 부하분산하며 전송하는 역할을 담당한다
- 워크로드의 특성에 맞게 컨트롤러를 선택해서 쿠버네티스를 사용해야한다
